### 自动图块笔记

#### 1 . 问题来源
在做dual-grid system 的笔记时遇到一个问题：  
什么是15-piece tiles，  
什么是47-piece tiles。  于是去问期喵，期喵让我研究一下“自动图块”。

于是上知乎搜“自动图块”，搜到这篇回答：  
https://www.zhihu.com/question/61025506/answer/2354396555  
这个回答提到了：  
Marching squares算法。  
（鸦感觉这个算法起到的是怎么把一片区域围起来的作用，和15，47两个数字怎么来的没啥关系）。  

于是我又看了这个视频：  
![picture 0](images/65c55a5bf7fbceee4d12d38b2950c0071b84f04422efe99d8a71520d1214fff3.png)  
https://www.youtube.com/watch?v=QXeCCvGgHhk&list=LL&index=16

里面提到了这个工具：Tiled  
https://doc.mapeditor.org/en/stable/manual/terrain/  
的这里提到了这个网址：  
![picture 1](images/ea62a909fadc865fd317ff68852aac4acd04df1b92069cf617150ff8d7cdc88c.png)  
https://web.archive.org/web/20220712091710/http://cr31.co.uk/stagecast/wang/blob.html  
所以下面正式开始介绍。  

#### 2 . 解释15和47数字来源介绍
为了理解15和47两个数字，主要看这几部分就够了：  
![picture 2](images/3b6702b53bff51aab19523b25116928ecefb2ab7533c029e9d9e4f41a3fa7790.png)  

##### 2.1 Wang tiles重点
（1）Tiles have a 'fixed orientation', they are never rotated or reflected (turned over).  
![picture 3](images/432e00711416319385e881fd861bed918ab6d63d12cbaa0d0cec4aeb0bf301e2.png)  
由红圈可以看出不会旋转。  
（2）  
![picture 4](images/d7f53623f428a410840b920c381618bd68cd6bbcbc303c2ebaf33cde8d633bee.png)  
其实也不是完全at random的，肯定是有一定规律的。     
看这种情况：  
![picture 5](images/e11642e6f0f6f153d2fb0d1eeff44309734a637ba5a34807cfbbce76d794664e.png)   
就不是边与边连接部分颜色相同。  

##### (2.2) 2-edge tiles 重点
主要看边的，  
一个正方形有4条边，分别染上不同的颜色。  
e.g.  
0000

0001

0010  
0011

0100    
0101   
0110   
0111  

1000  
1001  
1010  
1011  
1100  
1101  
1110  
1111  

1代表黄色0代表蓝色

##### (2.3) 2-corner Wang Tiles
(1)Wang tilesets are usually edge tilesets. But we can also create a Wang tileset by considering the tile corners.   
一个正方形有4个角，每个角都有2种颜色。2^4是16种可能性。  
![picture 6](images/d33e484d32f5009161c6ec154c8d40f6c9a1505e5817337b6fd9847d1cbecfd8.png)  

（2）
It may seem that matching corners will produce similar results as matching edges, but this is not so. An edge only affects one adjacent tile, while matching a corner affects three adjacent tiles.  
![picture 7](images/5138db498d076c06fe7f368a0e8f97334d6c2c266f0d9b7fa20ba5312b91d894.png)  

【注意】上文说的是`a corner affects`，  
类似编号3和15这种方块，是好几个corner。  

##### (2.4) Blob Tileset
(1) A Blob tileset is a 47 tile subset of a 2-edge 2-corner Wang tileset.    

**2-edge + 2-corner Wang Tiles**


With two different types of edge and two different types of corner, we have 2^8 or 256 different tiles in a complete tileset.  

Generally though 256 tiles is too many to produce and use. However, there is an interesting subset of 47 tiles, known as **'Blob' tiles**.

Here is the Blob tileset. Below each tile, all possible 90 degree rotations (clockwise) are shown. Each is 4x the previous index, (mod 255).  
【注意在这里用到了旋转】  

![picture 8](images/fbe601cc7419b7cee54423bdea98640efad3e1a63559b40475f8cb7f233514f1.png)  
![picture 9](images/28730b8730a2d1cdb3f974cda6cb88d7933a39123005c12496d84ed696daed2d.png)  

#### 3 . Marching Squares
其他没读的好的参考资料：  
https://catlikecoding.com/unity/tutorials/marching-squares/  
https://urbanspr1nter.github.io/marchingsquares/  

笔记时参考这个视频记录的：  
https://www.youtube.com/watch?v=0ZONMNUKTfU&list=LL&index=18  

（1）
if I take my processing window and divide it into a two-dimensional grid, we could think of each cell of this grid as having a number.   
![picture 10](images/a4d33c5faf75da705a7958f8b5754b27ec9eccdb81a14300359a6d36a23c6381.png)  
That's how we visualize two-dimensional Perlin noise.  

But in order to make marching squares happen, I need to put a little twist on this.    
I don't actually want to think of the center of each one of these as having a number. I want to think of these spots here, where each square has four corners. And each of those four corners represents a number.  
![picture 11](images/f0435e699ec04f67a9653887834535d2973108fccd803f86f928381a6878d66d.png)   
processing代码：  
```java
float[][] field;
int rez = 10;
int cols, rows;

void setup(){
  size(600, 400);
  cols = width / rez;
  rows = height / rez;
  
  field = new float[cols][rows];
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      field[i][j] = random(1);
    }
  }
}

void draw(){
  background(0);
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      stroke(field[i][j]*255);
      strokeWeight(4);
      point(i * rez, j * rez);
    }
  }
}
```
![picture 12](images/d8a63c556535371152cf3cfebe0932f61b210dd1e7dc2ffe0c35eb602734fd88.png)  

（2）so the idea of marching squares is, what would be some algorithm to find contours and patterns in this array of numbers?  
So to demonstrate how this works, I think it would be actually easier for me to consider each one of these numerical values as just a zero or a one.  
```java
int[][] field;
int rez = 20;
int cols, rows;

void setup(){
  size(600, 400);
  cols = width / rez;
  rows = height / rez;
  
  field = new int[cols][rows];
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      field[i][j] = floor(random(2));
    }
  }
}

void draw(){
  background(127);
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      stroke(field[i][j]*255);
      strokeWeight(rez*0.4);
      point(i * rez, j * rez);
    }
  }
}
```
![picture 13](images/5bd0ae40fee4c307f26f602cf28979ad9415a88bc15c21e1de2d946c54982aa1.png)  

（3）The idea here is that, whichever ones are on or off, I want to seperate the ones that are on from the ones that are off.    
![picture 14](images/3eda90d4be2cd88da64c2ab737efafab079cf45258429cbe14b19226fbdb64b3.png)  

![picture 15](images/8b273a92741b2076de74f3126d188d642f8a2e7eb672c4ccd858d930f17a6adb.png)  

![picture 16](images/2b218840600937c5e696e81871c94ebcc58b4ea8197e5d9ae690aafef721852a.png)  
![picture 18](images/de3d095ffdd5a61ff60ade0230a5da79d4b344f9afa468fc9ac50e7d80ed4295.png)  

（4）  
the midpoint between the corners. Because that's what gonna connect the line.   
![picture 19](images/90acd18bf3873ba52381511d5df7010946454a987e68d76234635317c85ccf99.png)  
把这四个点分别叫a, b, c, d。  
一个像素的宽度是rez。  
左上为第一个点，右上为第二个点  
左下为第三个点，右下为第四个点。   
然后顺时针遍历。  
0001就是：  
0 0  
0 1  

代码：  
```java
int[][] field;
int rez = 20;
int cols, rows;

void setup(){
  size(600, 400);
  cols = 1 + width / rez;
  rows = 1 + height / rez;
  
  field = new int[cols][rows];
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      field[i][j] = floor(random(2));
    }
  }
}

void draw(){
  background(127);
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      //cols-1和rows-1是因为final column doesn't have any neighbors to the right
      stroke(field[i][j]*255);
      strokeWeight(rez*0.4);
      point(i * rez, j * rez);
    }
  }
  
  for(int i = 0; i < cols - 1; i++){
    for(int j = 0; j < rows - 1; j++){
      //cols-1和rows-1是因为final column doesn't have any neighbors to the right
      float x = i * rez;
      float y = j * rez;
      PVector a = new PVector(x + rez*0.5, y);
      PVector b = new PVector(x + rez, y + rez * 0.5);
      PVector c = new PVector(x + rez*0.5, y + rez);
      PVector d = new PVector(x, y + rez*0.5);
      
      strokeWeight(1);
      
      int state = getState(field[i][j], field[i+1][j], field[i+1][j+1], field[i][j+1]);
      //顺时针方向遍历4个corner哦
      switch (state) {
        case 1:
          line(c, d);
          break;
        case 2:
          line(b, c);
          break;
        case 3:
          line(b, d);
          break;
        case 4:
          line(a, b);
          break;
        case 5:
          line(a, d);
          line(b, c);
          break;
        case 6:
          line(a, c);
          break;
        case 7:
          line(a, d);
          break;
        case 8:
          line(a, d);
          break;
        case 9:
          line(a, c);
          break;
        case 10:
          line(a, b);
          line(c, d);
          break;
        case 11:
          line(a, b);
          break;
        case 12:
          line(b, d);
          break;
        case 13:
          line(b, c);
          break;
        case 14:
          line(c, d);
          break;
      }
    }
  }
   
}
void line(PVector v1, PVector v2){
  line(v1.x, v1.y, v2.x, v2.y);
}

int getState(int p1, int p2, int p3, int p4){
    //输入是二进制的数值，输出是10进制的数字
    //将grid四个corner的数字放到input中
    return p1*8 + p2*4 + p3*2 + p4*1;   
}
```
![picture 20](images/61b59b7308d2dde1e93a888f883dd603bfbf0e73baf4de58c21241aad990b0a5.png)  

#### 4 . 返回blob那个网页
![picture 21](images/cbb6711080515bbf0490fd3d36acd8e779172a2394c488ef5a1c22842eab1e58.png)  
这一块应该讲怎么生成随机地形的。  
方法1说的是：  
当一条边（无论上下左右）为0，它的两个corner都为0。  
但是这样生成的tile有一个问题：  
不能拼斜边，已知点的每个大方块会被划分成3x3的小方块。  
当点击这两个点时：   
![picture 22](images/3de84cc06a838991cac66ede1112f77d78c106adf5a98a84d5785a660cd1eba5.png)  
由于左边的样子不能封边，会生成右边的样子：  
![picture 25](images/77a27b34b3ffddba22dd7b39f3fff9e6b4313113ea5d0848e9df1d71a2e52360.png)  

但如果中间有过渡的方块，就可以生成封边的连通域：  
![picture 26](images/1fc224cd0b64afc47a33c7c0958b314db63d6c67b8a98b3986a28d8e0898d9d9.png)  
